<!-- Simulation Section -->
    <div class="relative py-24 px-6 bg-slate-900">
        <div class="max-w-7xl mx-auto">
            <div class="text-center mb-12">
                <h2 class="text-5xl md:text-6xl font-bold mb-6 bg-gradient-to-r from-blue-400 to-cyan-500 bg-clip-text text-transparent">
                    Live Simulation
                </h2>
                <p class="text-xl text-gray-400 max-w-3xl mx-auto">
                    Watch how our swarm technology coordinates to suppress wildfire threats
                </p>
            </div>

            <!-- Simulation Container -->
            <div class="relative bg-gradient-to-br from-slate-800 to-slate-900 rounded-3xl border-2 border-slate-700 overflow-hidden shadow-2xl">
                <div class="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-orange-500 via-red-500 to-purple-500"></div>
                
                <!-- Simulation Box -->
                <div id="simulationArea" class="relative w-full h-[600px] bg-black">
                    <canvas id="simCanvas" class="w-full h-full"></canvas>
                </div>

                <!-- Control Panel -->
                <div class="border-t border-slate-700 bg-slate-900/50 backdrop-blur-sm p-6">
                    <!-- Parameter Sliders -->
                    <div class="grid md:grid-cols-3 gap-6 mb-6">
                        <div class="bg-slate-800/50 p-4 rounded-lg">
                            <label class="block text-sm font-semibold text-gray-300 mb-2">
                                Omega (œâ) - Inertia: <span id="omegaValue" class="text-orange-400">0.7</span>
                            </label>
                            <input type="range" id="omegaSlider" min="0.1" max="1.0" step="0.1" value="0.7" 
                                class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-orange-500">
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0.1</span>
                                <span>1.0</span>
                            </div>
                        </div>
                        
                        <div class="bg-slate-800/50 p-4 rounded-lg">
                            <label class="block text-sm font-semibold text-gray-300 mb-2">
                                Phi P (œÜ‚Çö) - Personal: <span id="phipValue" class="text-blue-400">2.0</span>
                            </label>
                            <input type="range" id="phipSlider" min="0.5" max="3.0" step="0.1" value="2.0" 
                                class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0.5</span>
                                <span>3.0</span>
                            </div>
                        </div>
                        
                        <div class="bg-slate-800/50 p-4 rounded-lg">
                            <label class="block text-sm font-semibold text-gray-300 mb-2">
                                Phi G (œÜ·µç) - Global: <span id="phigValue" class="text-purple-400">2.0</span>
                            </label>
                            <input type="range" id="phigSlider" min="0.5" max="3.0" step="0.1" value="2.0" 
                                class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-purple-500">
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0.5</span>
                                <span>3.0</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Control Buttons -->
                    <div class="flex flex-wrap gap-4 justify-center items-center">
                        <button id="startBtn" class="px-6 py-3 bg-gradient-to-r from-green-500 to-emerald-600 rounded-lg font-semibold hover:from-green-600 hover:to-emerald-700 transition-all duration-300 shadow-lg shadow-green-500/25">
                            Start Simulation
                        </button>
                        <button id="stopBtn" class="px-6 py-3 bg-gradient-to-r from-red-500 to-orange-600 rounded-lg font-semibold hover:from-red-600 hover:to-orange-700 transition-all duration-300 shadow-lg shadow-red-500/25">
                            Stop
                        </button>
                        <button id="resetBtn" class="px-6 py-3 bg-slate-700 hover:bg-slate-600 rounded-lg font-semibold transition-all duration-300">
                            Reset
                        </button>
                        <div class="flex items-center gap-3 px-6 py-3 bg-slate-800 rounded-lg">
                            <span class="text-gray-400">Drones:</span>
                            <span id="droneCount" class="font-bold text-blue-400">0</span>
                        </div>
                        <div class="flex items-center gap-3 px-6 py-3 bg-slate-800 rounded-lg">
                            <span class="text-gray-400">Fires:</span>
                            <span id="fireCount" class="font-bold text-orange-400">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div class="relative py-12 px-6 bg-black border-t border-slate-800">
        <div class="max-w-7xl mx-auto text-center text-gray-500">
            <p>¬© 2025 Swarm Intelligence Systems. Next-generation wildfire response technology.</p>
        </div>
    </div>

    <script>
        // Simulation Parameters
        let omega = 0.7;
        let phip = 2.0;
        let phig = 2.0;
        let isRunning = false;
        let animationId = null;

        // Canvas setup
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const container = document.getElementById('simulationArea');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Environment and simulation state
        const GRID_WIDTH = 40;
        const GRID_HEIGHT = 20;
        const CELL_SIZE = canvas.width / GRID_WIDTH;
        
        let grid = [];
        let fires = [];
        let drones = [];
        const NUM_DRONES = 20;

        // Initialize grid
        function initGrid() {
            grid = [];
            for (let y = 0; y < GRID_HEIGHT; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    grid[y][x] = {
                        tree: true,
                        fire: false,
                        burnt: false,
                        water: false,
                        extinguishedByDrone: false
                    };
                }
            }
            
            // Add water blobs
            for (let i = 0; i < 3; i++) {
                const cx = Math.floor(Math.random() * (GRID_WIDTH - 10)) + 5;
                const cy = Math.floor(Math.random() * (GRID_HEIGHT - 10)) + 5;
                const steps = Math.floor(Math.random() * 15) + 15;
                let x = cx, y = cy;
                for (let s = 0; s < steps; s++) {
                    if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                        grid[y][x].water = true;
                        grid[y][x].tree = false;
                    }
                    x += Math.floor(Math.random() * 3) - 1;
                    y += Math.floor(Math.random() * 3) - 1;
                }
            }
            
            // Start some fires
            fires = [];
            for (let i = 0; i < 5; i++) {
                const x = Math.floor(Math.random() * (GRID_WIDTH / 3)) + GRID_WIDTH / 3;
                const y = Math.floor(Math.random() * (GRID_HEIGHT / 3)) + GRID_HEIGHT / 3;
                if (grid[y][x].tree) {
                    grid[y][x].fire = true;
                    fires.push({x, y, cooldown: 3});
                }
            }
        }

        // Initialize drones
        function initDrones() {
            drones = [];
            for (let i = 0; i < NUM_DRONES; i++) {
                drones.push({
                    x: Math.random() * GRID_WIDTH,
                    y: Math.random() * GRID_HEIGHT,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    pbestX: GRID_WIDTH / 2,
                    pbestY: GRID_HEIGHT / 2,
                    pbestFitness: Infinity,
                    firesExtinguished: 0
                });
            }
        }

        // Calculate fitness for a position
        function calculateFitness(x, y) {
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            
            if (ix < 0 || ix >= GRID_WIDTH || iy < 0 || iy >= GRID_HEIGHT) {
                return 1e6;
            }
            
            // If on fire, very good position
            if (grid[iy][ix].fire) {
                return -100;
            }
            
            // If on water, good for refilling
            if (grid[iy][ix].water) {
                return -10;
            }
            
            // If burnt, bad position
            if (grid[iy][ix].burnt) {
                return 1000;
            }
            
            // Otherwise, distance to nearest fire
            let minDist = Infinity;
            for (const fire of fires) {
                const dist = Math.sqrt((fire.x - x) ** 2 + (fire.y - y) ** 2);
                minDist = Math.min(minDist, dist);
            }
            
            return minDist;
        }

        // Find best position (global best)
        function findBestPosition() {
            let bestX = GRID_WIDTH / 2;
            let bestY = GRID_HEIGHT / 2;
            let bestFitness = Infinity;
            
            for (const drone of drones) {
                const fitness = calculateFitness(drone.x, drone.y);
                if (fitness < bestFitness) {
                    bestFitness = fitness;
                    bestX = drone.x;
                    bestY = drone.y;
                }
            }
            
            // If no good position found, target first fire
            if (fires.length > 0 && bestFitness > 0) {
                bestX = fires[0].x;
                bestY = fires[0].y;
            }
            
            return {x: bestX, y: bestY};
        }

        // Update drones using PSO
        function updateDrones() {
            const gbest = findBestPosition();
            
            for (let drone of drones) {
                const rp = Math.random();
                const rg = Math.random();
                
                // Calculate current fitness
                const currentFitness = calculateFitness(drone.x, drone.y);
                
                // Update personal best
                if (currentFitness < drone.pbestFitness) {
                    drone.pbestX = drone.x;
                    drone.pbestY = drone.y;
                    drone.pbestFitness = currentFitness;
                }
                
                // PSO velocity update with user-controlled parameters
                drone.vx = omega * drone.vx + 
                          phip * rp * (drone.pbestX - drone.x) + 
                          phig * rg * (gbest.x - drone.x);
                          
                drone.vy = omega * drone.vy + 
                          phip * rp * (drone.pbestY - drone.y) + 
                          phig * rg * (gbest.y - drone.y);
                
                // Add small random noise
                drone.vx += (Math.random() - 0.5) * 0.3;
                drone.vy += (Math.random() - 0.5) * 0.3;
                
                // Limit velocity
                const maxVel = 1.5;
                const vel = Math.sqrt(drone.vx ** 2 + drone.vy ** 2);
                if (vel > maxVel) {
                    drone.vx = (drone.vx / vel) * maxVel;
                    drone.vy = (drone.vy / vel) * maxVel;
                }
                
                // Update position
                drone.x += drone.vx;
                drone.y += drone.vy;
                
                // Boundary checks
                drone.x = Math.max(0, Math.min(GRID_WIDTH - 1, drone.x));
                drone.y = Math.max(0, Math.min(GRID_HEIGHT - 1, drone.y));
                
                // Extinguish nearby fires (3x3 area)
                const ix = Math.floor(drone.x);
                const iy = Math.floor(drone.y);
                let extinguished = 0;
                for (let dx = -1; dx <= 1 && extinguished < 3; dx++) {
                    for (let dy = -1; dy <= 1 && extinguished < 3; dy++) {
                        const nx = ix + dx;
                        const ny = iy + dy;
                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                            if (grid[ny][nx].fire) {
                                grid[ny][nx].fire = false;
                                grid[ny][nx].burnt = true;
                                grid[ny][nx].tree = false;
                                grid[ny][nx].extinguishedByDrone = true;
                                extinguished++;
                                drone.firesExtinguished++;
                            }
                        }
                    }
                }
            }
        }

        // Spread fire
        function spreadFire() {
            const newFires = [];
            const stillActive = [];
            
            for (let fire of fires) {
                // Check if fire still exists
                if (!grid[fire.y][fire.x].fire) {
                    continue;
                }
                
                if (fire.cooldown > 0) {
                    fire.cooldown--;
                    stillActive.push(fire);
                    continue;
                }
                
                // Random burnout (3% chance)
                if (Math.random() < 0.03) {
                    grid[fire.y][fire.x].fire = false;
                    grid[fire.y][fire.x].burnt = true;
                    grid[fire.y][fire.x].extinguishedByDrone = false;
                    continue;
                }
                
                // Spread to neighbors
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = fire.x + dx;
                        const ny = fire.y + dy;
                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                            const ncell = grid[ny][nx];
                            if (ncell.tree && !ncell.fire && !ncell.water && !ncell.burnt) {
                                let prob = 0.05; // base probability
                                
                                // Wind effect (assume wind is (1, 0) - right)
                                if (dx === 1 && dy === 0) {
                                    prob += 0.08;
                                }
                                
                                if (Math.random() < prob) {
                                    ncell.fire = true;
                                    ncell.tree = false;
                                    newFires.push({x: nx, y: ny, cooldown: 3});
                                }
                            }
                        }
                    }
                }
                fire.cooldown = 3;
                stillActive.push(fire);
            }
            fires = stillActive.concat(newFires);
        }

        // Draw simulation with emojis
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cellW = canvas.width / GRID_WIDTH;
            const cellH = canvas.height / GRID_HEIGHT;
            
            // Calculate emoji size based on cell size
            const emojiSize = Math.max(12, Math.min(cellW, cellH) * 0.8);
            ctx.font = emojiSize + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Create drone position map for quick lookup
            const dronePositions = new Set();
            for (const drone of drones) {
                const key = Math.floor(drone.x) + ',' + Math.floor(drone.y);
                dronePositions.add(key);
            }
            
            // Draw cells with emojis
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const centerX = x * cellW + cellW / 2;
                    const centerY = y * cellH + cellH / 2;
                    const key = x + ',' + y;
                    
                    // Check if drone is at this position first
                    if (dronePositions.has(key)) {
                        ctx.fillText('üöÅ', centerX, centerY);
                    } else {
                        const cell = grid[y][x];
                        let emoji = '';
                        
                        if (cell.fire) {
                            emoji = 'üî•';
                        } else if (cell.burnt && cell.extinguishedByDrone) {
                            emoji = 'üü©';
                        } else if (cell.burnt) {
                            emoji = '‚¨õ';
                        } else if (cell.water) {
                            emoji = 'üî∑';
                        } else if (cell.tree) {
                            emoji = 'üå≤';
                        }
                        
                        if (emoji) {
                            ctx.fillText(emoji, centerX, centerY);
                        }
                    }
                }
            }
            
            // Update counters
            document.getElementById('droneCount').textContent = drones.length;
            document.getElementById('fireCount').textContent = fires.length;
        }

        // Animation loop
        function animate() {
            if (!isRunning) return;
            
            spreadFire();
            updateDrones();
            draw();
            
            if (fires.length === 0) {
                isRunning = false;
                setTimeout(() => {
                    alert('üéâ All fires extinguished!');
                }, 100);
                return;
            }
            
            setTimeout(() => {
                animationId = requestAnimationFrame(animate);
            }, 250); // 250ms = 4 frames per second, like watching terminal output
        }

        // Slider event listeners
        document.getElementById('omegaSlider').addEventListener('input', function(e) {
            omega = parseFloat(e.target.value);
            document.getElementById('omegaValue').textContent = omega.toFixed(1);
        });

        document.getElementById('phipSlider').addEventListener('input', function(e) {
            phip = parseFloat(e.target.value);
            document.getElementById('phipValue').textContent = phip.toFixed(1);
        });

        document.getElementById('phigSlider').addEventListener('input', function(e) {
            phig = parseFloat(e.target.value);
            document.getElementById('phigValue').textContent = phig.toFixed(1);
        });

        // Button controls
        document.getElementById('startBtn').addEventListener('click', function() {
            if (!isRunning) {
                if (drones.length === 0) {
                    initDrones();
                }
                isRunning = true;
                animate();
            }
        });

        document.getElementById('stopBtn').addEventListener('click', function() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', function() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            initGrid();
            initDrones();
            draw();
        });

        // Initialize
        initGrid();
        draw();

        // Generate floating drones for hero section
        const dronesContainer = document.getElementById('floatingDrones');
        for (let i = 0; i < 8; i++) {
            const drone = document.createElement('div');
            drone.className = 'absolute text-blue-400 opacity-60 float-animation';
            drone.style.left = Math.random() * 100 + '%';
            drone.style.top = Math.random() * 60 + '%';
            drone.style.animationDuration = Math.random() * 3 + 4 + 's';
            drone.style.animationDelay = Math.random() * 2 + 's';
            drone.innerHTML = '<div class="relative"><div class="w-3 h-3 bg-blue-500 rounded-full shadow-lg shadow-blue-500/50"></div><div class="absolute -top-1 -left-1 w-5 h-5 border border-blue-400 rounded-full animate-ping"></div></div>';
            dronesContainer.appendChild(drone);
        }

        // Parallax effect on hero content
        const heroContent = document.getElementById('heroContent');
        window.addEventListener('scroll', function() {
            const scrollY = window.scrollY;
            heroContent.style.transform = 'translateY(' + scrollY * 0.5 + 'px)';
            heroContent.style.opacity = 1 - scrollY / 500;
        });
    </script>
</body>
</html>


